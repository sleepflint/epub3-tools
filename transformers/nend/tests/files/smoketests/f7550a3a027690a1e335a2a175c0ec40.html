<?xml version="1.0"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops"><head><title>Structure and Interpretation of Computer Programs</title></head><body>
    
    
    <nav id="toc" epub:type="toc"><h1>Contents</h1><ol>
<li id="navPoint-1"><a href="book-Z-H-1.html">Structure and Interpretation of Computer Programs</a></li>
<li id="navPoint-2"><a href="book-Z-H-9.html">Chapter 1</a><ol>
<li id="navPoint-3"><a href="book-Z-H-9.html#heading_id_3">Programming in Lisp</a></li>
<li id="navPoint-4"><a href="book-Z-H-10.html">1.1 The Elements of Programming</a><ol>
<li id="navPoint-5"><a href="book-Z-H-10.html#heading_id_3">1.1.1 Expressions</a></li>
<li id="navPoint-6"><a href="book-Z-H-10.html#heading_id_4">1.1.2 Naming and the Environment</a></li>
<li id="navPoint-7"><a href="book-Z-H-10.html#heading_id_5">1.1.3 Evaluating Combinations</a></li>
<li id="navPoint-8"><a href="book-Z-H-10.html#heading_id_6">1.1.4 Compound Procedures</a></li>
<li id="navPoint-9"><a href="book-Z-H-10.html#heading_id_7">1.1.5 The Substitution Model for Procedure Application</a><ol>
<li id="navPoint-10"><a href="book-Z-H-10.html#heading_id_8">Applicative order versus normal order</a></li></ol></li>
<li id="navPoint-11"><a href="book-Z-H-10.html#heading_id_9">1.1.6 Conditional Expressions and Predicates</a></li>
<li id="navPoint-12"><a href="book-Z-H-10.html#heading_id_10">1.1.7 Example: Square Roots by Newton's Method</a></li>
<li id="navPoint-13"><a href="book-Z-H-10.html#heading_id_11">1.1.8 Procedures as Black-Box Abstractions</a><ol>
<li id="navPoint-14"><a href="book-Z-H-10.html#heading_id_12">Local names</a></li>
<li id="navPoint-15"><a href="book-Z-H-10.html#heading_id_13">Internal definitions and block structure</a></li></ol></li></ol></li>
<li id="navPoint-16"><a href="book-Z-H-11.html">1.2 Procedures and the Processes They Generate</a><ol>
<li id="navPoint-17"><a href="book-Z-H-11.html#heading_id_3">1.2.1 Linear Recursion and Iteration</a></li>
<li id="navPoint-18"><a href="book-Z-H-11.html#heading_id_4">1.2.2 Tree Recursion</a><ol>
<li id="navPoint-19"><a href="book-Z-H-11.html#heading_id_5">Example: Counting change</a></li></ol></li>
<li id="navPoint-20"><a href="book-Z-H-11.html#heading_id_6">1.2.3 Orders of Growth</a></li>
<li id="navPoint-21"><a href="book-Z-H-11.html#heading_id_7">1.2.4 Exponentiation</a></li>
<li id="navPoint-22"><a href="book-Z-H-11.html#heading_id_8">1.2.5 Greatest Common Divisors</a></li>
<li id="navPoint-23"><a href="book-Z-H-11.html#heading_id_9">1.2.6 Example: Testing for Primality</a><ol>
<li id="navPoint-24"><a href="book-Z-H-11.html#heading_id_10">Searching for divisors</a></li>
<li id="navPoint-25"><a href="book-Z-H-11.html#heading_id_11">The Fermat test</a></li>
<li id="navPoint-26"><a href="book-Z-H-11.html#heading_id_12">Probabilistic methods</a></li></ol></li></ol></li>
<li id="navPoint-27"><a href="book-Z-H-12.html">1.3 Formulating Abstractions with Higher-Order Procedures</a><ol>
<li id="navPoint-28"><a href="book-Z-H-12.html#heading_id_3">1.3.1 Procedures as Arguments</a></li>
<li id="navPoint-29"><a href="book-Z-H-12.html#heading_id_4">1.3.2 Constructing Procedures Using Lambda</a><ol>
<li id="navPoint-30"><a href="book-Z-H-12.html#heading_id_5">Using let to create local variables</a></li></ol></li>
<li id="navPoint-31"><a href="book-Z-H-12.html#heading_id_6">1.3.3 Procedures as General Methods</a><ol>
<li id="navPoint-32"><a href="book-Z-H-12.html#heading_id_7">Finding roots of equations by the half-interval method</a></li>
<li id="navPoint-33"><a href="book-Z-H-12.html#heading_id_8">Finding fixed points of functions</a></li></ol></li>
<li id="navPoint-34"><a href="book-Z-H-12.html#heading_id_9">1.3.4 Procedures as Returned Values</a><ol>
<li id="navPoint-35"><a href="book-Z-H-12.html#heading_id_10">Newton's method</a></li>
<li id="navPoint-36"><a href="book-Z-H-12.html#heading_id_11">Abstractions and first-class procedures</a></li></ol></li></ol></li></ol></li>
<li id="navPoint-37"><a href="book-Z-H-13.html">Chapter 2</a><ol>
<li id="navPoint-38"><a href="book-Z-H-14.html">2.1 Introduction to Data Abstraction</a><ol>
<li id="navPoint-39"><a href="book-Z-H-14.html#heading_id_3">2.1.1 Example: Arithmetic Operations for Rational Numbers</a><ol>
<li id="navPoint-40"><a href="book-Z-H-14.html#heading_id_4">Pairs</a></li>
<li id="navPoint-41"><a href="book-Z-H-14.html#heading_id_5">Representing rational numbers</a></li></ol></li>
<li id="navPoint-42"><a href="book-Z-H-14.html#heading_id_6">2.1.2 Abstraction Barriers</a></li>
<li id="navPoint-43"><a href="book-Z-H-14.html#heading_id_7">2.1.3 What Is Meant by Data?</a></li>
<li id="navPoint-44"><a href="book-Z-H-14.html#heading_id_8">2.1.4 Extended Exercise: Interval Arithmetic</a></li></ol></li>
<li id="navPoint-45"><a href="book-Z-H-15.html">2.2 Hierarchical Data and the Closure Property</a><ol>
<li id="navPoint-46"><a href="book-Z-H-15.html#heading_id_3">2.2.1 Representing Sequences</a><ol>
<li id="navPoint-47"><a href="book-Z-H-15.html#heading_id_4">List operations</a></li>
<li id="navPoint-48"><a href="book-Z-H-15.html#heading_id_5">Mapping over lists</a></li></ol></li>
<li id="navPoint-49"><a href="book-Z-H-15.html#heading_id_6">2.2.2 Hierarchical Structures</a><ol>
<li id="navPoint-50"><a href="book-Z-H-15.html#heading_id_7">Mapping over trees</a></li></ol></li>
<li id="navPoint-51"><a href="book-Z-H-15.html#heading_id_8">2.2.3 Sequences as Conventional Interfaces</a><ol>
<li id="navPoint-52"><a href="book-Z-H-15.html#heading_id_9">Sequence Operations</a></li>
<li id="navPoint-53"><a href="book-Z-H-15.html#heading_id_10">Nested Mappings</a></li></ol></li>
<li id="navPoint-54"><a href="book-Z-H-15.html#heading_id_11">2.2.4 Example: A Picture Language</a><ol>
<li id="navPoint-55"><a href="book-Z-H-15.html#heading_id_12">The picture language</a></li>
<li id="navPoint-56"><a href="book-Z-H-15.html#heading_id_13">Higher-order operations</a></li>
<li id="navPoint-57"><a href="book-Z-H-15.html#heading_id_14">Frames</a></li>
<li id="navPoint-58"><a href="book-Z-H-15.html#heading_id_15">Painters</a></li>
<li id="navPoint-59"><a href="book-Z-H-15.html#heading_id_16">Transforming and combining painters</a></li>
<li id="navPoint-60"><a href="book-Z-H-15.html#heading_id_17">Levels of language for robust design</a></li></ol></li></ol></li>
<li id="navPoint-61"><a href="book-Z-H-16.html">2.3 Symbolic Data</a><ol>
<li id="navPoint-62"><a href="book-Z-H-16.html#heading_id_3">2.3.1 Quotation</a></li>
<li id="navPoint-63"><a href="book-Z-H-16.html#heading_id_4">2.3.2 Example: Symbolic Differentiation</a><ol>
<li id="navPoint-64"><a href="book-Z-H-16.html#heading_id_5">The differentiation program with abstract data</a></li>
<li id="navPoint-65"><a href="book-Z-H-16.html#heading_id_6">Representing algebraic expressions</a></li></ol></li>
<li id="navPoint-66"><a href="book-Z-H-16.html#heading_id_7">2.3.3 Example: Representing Sets</a><ol>
<li id="navPoint-67"><a href="book-Z-H-16.html#heading_id_8">Sets as unordered lists</a></li>
<li id="navPoint-68"><a href="book-Z-H-16.html#heading_id_9">Sets as ordered lists</a></li>
<li id="navPoint-69"><a href="book-Z-H-16.html#heading_id_10">Sets as binary trees</a></li>
<li id="navPoint-70"><a href="book-Z-H-16.html#heading_id_11">Sets and information retrieval</a></li></ol></li>
<li id="navPoint-71"><a href="book-Z-H-16.html#heading_id_12">2.3.4 Example: Huffman Encoding Trees</a><ol>
<li id="navPoint-72"><a href="book-Z-H-16.html#heading_id_13">Generating Huffman trees</a></li>
<li id="navPoint-73"><a href="book-Z-H-16.html#heading_id_14">Representing Huffman trees</a></li>
<li id="navPoint-74"><a href="book-Z-H-16.html#heading_id_15">The decoding procedure</a></li>
<li id="navPoint-75"><a href="book-Z-H-16.html#heading_id_16">Sets of weighted elements</a></li></ol></li></ol></li>
<li id="navPoint-76"><a href="book-Z-H-17.html">2.4 Multiple Representations for Abstract Data</a><ol>
<li id="navPoint-77"><a href="book-Z-H-17.html#heading_id_3">2.4.1 Representations for Complex Numbers</a></li>
<li id="navPoint-78"><a href="book-Z-H-17.html#heading_id_4">2.4.2 Tagged data</a></li>
<li id="navPoint-79"><a href="book-Z-H-17.html#heading_id_5">2.4.3 Data-Directed Programming and Additivity</a><ol>
<li id="navPoint-80"><a href="book-Z-H-17.html#heading_id_6">Message passing</a></li></ol></li></ol></li>
<li id="navPoint-81"><a href="book-Z-H-18.html">2.5 Systems with Generic Operations</a><ol>
<li id="navPoint-82"><a href="book-Z-H-18.html#heading_id_3">2.5.1 Generic Arithmetic Operations</a></li>
<li id="navPoint-83"><a href="book-Z-H-18.html#heading_id_4">2.5.2 Combining Data of Different Types</a><ol>
<li id="navPoint-84"><a href="book-Z-H-18.html#heading_id_5">Coercion</a></li>
<li id="navPoint-85"><a href="book-Z-H-18.html#heading_id_6">Hierarchies of types</a></li>
<li id="navPoint-86"><a href="book-Z-H-18.html#heading_id_7">Inadequacies of hierarchies</a></li></ol></li>
<li id="navPoint-87"><a href="book-Z-H-18.html#heading_id_8">2.5.3 Example: Symbolic Algebra</a><ol>
<li id="navPoint-88"><a href="book-Z-H-18.html#heading_id_9">Arithmetic on polynomials</a></li>
<li id="navPoint-89"><a href="book-Z-H-18.html#heading_id_10">Representing term lists</a></li>
<li id="navPoint-90"><a href="book-Z-H-18.html#heading_id_11">Hierarchies of types in symbolic algebra</a></li>
<li id="navPoint-91"><a href="book-Z-H-18.html#heading_id_12">Extended exercise: Rational functions</a></li></ol></li></ol></li></ol></li>
<li id="navPoint-92"><a href="book-Z-H-19.html">Chapter 3</a><ol>
<li id="navPoint-93"><a href="book-Z-H-20.html">3.1 Assignment and Local State</a><ol>
<li id="navPoint-94"><a href="book-Z-H-20.html#heading_id_3">3.1.1 Local State Variables</a></li>
<li id="navPoint-95"><a href="book-Z-H-20.html#heading_id_4">3.1.2 The Benefits of Introducing Assignment</a></li>
<li id="navPoint-96"><a href="book-Z-H-20.html#heading_id_5">3.1.3 The Costs of Introducing Assignment</a><ol>
<li id="navPoint-97"><a href="book-Z-H-20.html#heading_id_6">Sameness and change</a></li>
<li id="navPoint-98"><a href="book-Z-H-20.html#heading_id_7">Pitfalls of imperative programming</a></li></ol></li></ol></li>
<li id="navPoint-99"><a href="book-Z-H-21.html">3.2 The Environment Model of Evaluation</a><ol>
<li id="navPoint-100"><a href="book-Z-H-21.html#heading_id_3">3.2.1 The Rules for Evaluation</a></li>
<li id="navPoint-101"><a href="book-Z-H-21.html#heading_id_4">3.2.2 Applying Simple Procedures</a></li>
<li id="navPoint-102"><a href="book-Z-H-21.html#heading_id_5">3.2.3 Frames as the Repository of Local State</a></li>
<li id="navPoint-103"><a href="book-Z-H-21.html#heading_id_6">3.2.4 Internal Definitions</a></li></ol></li>
<li id="navPoint-104"><a href="book-Z-H-22.html">3.3 Modeling with Mutable Data</a><ol>
<li id="navPoint-105"><a href="book-Z-H-22.html#heading_id_3">3.3.1 Mutable List Structure</a><ol>
<li id="navPoint-106"><a href="book-Z-H-22.html#heading_id_4">Sharing and identity</a></li>
<li id="navPoint-107"><a href="book-Z-H-22.html#heading_id_5">Mutation is just assignment</a></li></ol></li>
<li id="navPoint-108"><a href="book-Z-H-22.html#heading_id_6">3.3.2 Representing Queues</a></li>
<li id="navPoint-109"><a href="book-Z-H-22.html#heading_id_7">3.3.3 Representing Tables</a><ol>
<li id="navPoint-110"><a href="book-Z-H-22.html#heading_id_8">Two-dimensional tables</a></li>
<li id="navPoint-111"><a href="book-Z-H-22.html#heading_id_9">Creating local tables</a></li></ol></li>
<li id="navPoint-112"><a href="book-Z-H-22.html#heading_id_10">3.3.4 A Simulator for Digital Circuits</a><ol>
<li id="navPoint-113"><a href="book-Z-H-22.html#heading_id_11">Primitive function boxes</a></li>
<li id="navPoint-114"><a href="book-Z-H-22.html#heading_id_12">Representing wires</a></li>
<li id="navPoint-115"><a href="book-Z-H-22.html#heading_id_13">The agenda</a></li>
<li id="navPoint-116"><a href="book-Z-H-22.html#heading_id_14">A sample simulation</a></li>
<li id="navPoint-117"><a href="book-Z-H-22.html#heading_id_15">Implementing the agenda</a></li></ol></li>
<li id="navPoint-118"><a href="book-Z-H-22.html#heading_id_16">3.3.5 Propagation of Constraints</a><ol>
<li id="navPoint-119"><a href="book-Z-H-22.html#heading_id_17">Using the constraint system</a></li>
<li id="navPoint-120"><a href="book-Z-H-22.html#heading_id_18">Implementing the constraint system</a></li>
<li id="navPoint-121"><a href="book-Z-H-22.html#heading_id_19">Representing connectors</a></li></ol></li></ol></li>
<li id="navPoint-122"><a href="book-Z-H-23.html">3.4 Concurrency: Time Is of the Essence</a><ol>
<li id="navPoint-123"><a href="book-Z-H-23.html#heading_id_3">3.4.1 The Nature of Time in Concurrent Systems</a><ol>
<li id="navPoint-124"><a href="book-Z-H-23.html#heading_id_4">Correct behavior of concurrent programs</a></li></ol></li>
<li id="navPoint-125"><a href="book-Z-H-23.html#heading_id_5">3.4.2 Mechanisms for Controlling Concurrency</a><ol>
<li id="navPoint-126"><a href="book-Z-H-23.html#heading_id_6">Serializing access to shared state</a></li>
<li id="navPoint-127"><a href="book-Z-H-23.html#heading_id_7">Serializers in Scheme</a></li>
<li id="navPoint-128"><a href="book-Z-H-23.html#heading_id_8">Complexity of using multiple shared resources</a></li>
<li id="navPoint-129"><a href="book-Z-H-23.html#heading_id_9">Implementing serializers</a></li>
<li id="navPoint-130"><a href="book-Z-H-23.html#heading_id_10">Deadlock</a></li>
<li id="navPoint-131"><a href="book-Z-H-23.html#heading_id_11">Concurrency, time, and communication</a></li></ol></li></ol></li>
<li id="navPoint-132"><a href="book-Z-H-24.html">3.5 Streams</a><ol>
<li id="navPoint-133"><a href="book-Z-H-24.html#heading_id_3">3.5.1 Streams Are Delayed Lists</a><ol>
<li id="navPoint-134"><a href="book-Z-H-24.html#heading_id_4">The stream implementation in action</a></li>
<li id="navPoint-135"><a href="book-Z-H-24.html#heading_id_5">Implementing delay and force</a></li></ol></li>
<li id="navPoint-136"><a href="book-Z-H-24.html#heading_id_6">3.5.2 Infinite Streams</a><ol>
<li id="navPoint-137"><a href="book-Z-H-24.html#heading_id_7">Defining streams implicitly</a></li></ol></li>
<li id="navPoint-138"><a href="book-Z-H-24.html#heading_id_8">3.5.3 Exploiting the Stream Paradigm</a><ol>
<li id="navPoint-139"><a href="book-Z-H-24.html#heading_id_9">Formulating iterations as stream processes</a></li>
<li id="navPoint-140"><a href="book-Z-H-24.html#heading_id_10">Infinite streams of pairs</a></li>
<li id="navPoint-141"><a href="book-Z-H-24.html#heading_id_11">Streams as signals</a></li></ol></li>
<li id="navPoint-142"><a href="book-Z-H-24.html#heading_id_12">3.5.4 Streams and Delayed Evaluation</a><ol>
<li id="navPoint-143"><a href="book-Z-H-24.html#heading_id_13">Normal-order evaluation</a></li></ol></li>
<li id="navPoint-144"><a href="book-Z-H-24.html#heading_id_14">3.5.5 Modularity of Functional Programs and Modularity of Objects</a><ol>
<li id="navPoint-145"><a href="book-Z-H-24.html#heading_id_15">A functional-programming view of time</a></li></ol></li></ol></li></ol></li>
<li id="navPoint-146"><a href="book-Z-H-25.html">Chapter 4</a><ol>
<li id="navPoint-147"><a href="book-Z-H-26.html">4.1 The Metacircular Evaluator</a><ol>
<li id="navPoint-148"><a href="book-Z-H-26.html#heading_id_3">4.1.1 The Core of the Evaluator</a><ol>
<li id="navPoint-149"><a href="book-Z-H-26.html#heading_id_4">Eval</a><ol>
<li id="navPoint-150"><a href="book-Z-H-26.html#heading_id_5">Primitive expressions</a></li>
<li id="navPoint-151"><a href="book-Z-H-26.html#heading_id_6">Special forms</a></li>
<li id="navPoint-152"><a href="book-Z-H-26.html#heading_id_7">Combinations</a></li></ol></li>
<li id="navPoint-153"><a href="book-Z-H-26.html#heading_id_8">Apply</a></li>
<li id="navPoint-154"><a href="book-Z-H-26.html#heading_id_9">Procedure arguments</a></li>
<li id="navPoint-155"><a href="book-Z-H-26.html#heading_id_10">Conditionals</a></li>
<li id="navPoint-156"><a href="book-Z-H-26.html#heading_id_11">Sequences</a></li>
<li id="navPoint-157"><a href="book-Z-H-26.html#heading_id_12">Assignments and definitions</a></li></ol></li>
<li id="navPoint-158"><a href="book-Z-H-26.html#heading_id_13">4.1.2 Representing Expressions</a><ol>
<li id="navPoint-159"><a href="book-Z-H-26.html#heading_id_14">Derived expressions</a></li></ol></li>
<li id="navPoint-160"><a href="book-Z-H-26.html#heading_id_15">4.1.3 Evaluator Data Structures</a><ol>
<li id="navPoint-161"><a href="book-Z-H-26.html#heading_id_16">Testing of predicates</a></li>
<li id="navPoint-162"><a href="book-Z-H-26.html#heading_id_17">Representing procedures</a></li>
<li id="navPoint-163"><a href="book-Z-H-26.html#heading_id_18">Operations on Environments</a></li></ol></li>
<li id="navPoint-164"><a href="book-Z-H-26.html#heading_id_19">4.1.4 Running the Evaluator as a Program</a></li>
<li id="navPoint-165"><a href="book-Z-H-26.html#heading_id_20">4.1.5 Data as Programs</a></li>
<li id="navPoint-166"><a href="book-Z-H-26.html#heading_id_21">4.1.6 Internal Definitions</a></li>
<li id="navPoint-167"><a href="book-Z-H-26.html#heading_id_22">4.1.7 Separating Syntactic Analysis from Execution</a></li></ol></li>
<li id="navPoint-168"><a href="book-Z-H-27.html">4.2 Variations on a Scheme – Lazy Evaluation</a><ol>
<li id="navPoint-169"><a href="book-Z-H-27.html#heading_id_3">4.2.1 Normal Order and Applicative Order</a></li>
<li id="navPoint-170"><a href="book-Z-H-27.html#heading_id_4">4.2.2 An Interpreter with Lazy Evaluation</a><ol>
<li id="navPoint-171"><a href="book-Z-H-27.html#heading_id_5">Modifying the evaluator</a></li>
<li id="navPoint-172"><a href="book-Z-H-27.html#heading_id_6">Representing thunks</a></li></ol></li>
<li id="navPoint-173"><a href="book-Z-H-27.html#heading_id_7">4.2.3 Streams as Lazy Lists</a></li></ol></li>
<li id="navPoint-174"><a href="book-Z-H-28.html">4.3 Variations on a Scheme – Nondeterministic Computing</a><ol>
<li id="navPoint-175"><a href="book-Z-H-28.html#heading_id_3">4.3.1 Amb and Search</a><ol>
<li id="navPoint-176"><a href="book-Z-H-28.html#heading_id_4">Driver loop</a></li></ol></li>
<li id="navPoint-177"><a href="book-Z-H-28.html#heading_id_5">4.3.2 Examples of Nondeterministic Programs</a><ol>
<li id="navPoint-178"><a href="book-Z-H-28.html#heading_id_6">Logic Puzzles</a></li>
<li id="navPoint-179"><a href="book-Z-H-28.html#heading_id_7">Parsing natural language</a></li></ol></li>
<li id="navPoint-180"><a href="book-Z-H-28.html#heading_id_8">4.3.3 Implementing the Amb Evaluator</a><ol>
<li id="navPoint-181"><a href="book-Z-H-28.html#heading_id_9">Execution procedures and continuations</a></li>
<li id="navPoint-182"><a href="book-Z-H-28.html#heading_id_10">Structure of the evaluator</a></li>
<li id="navPoint-183"><a href="book-Z-H-28.html#heading_id_11">Simple expressions</a></li>
<li id="navPoint-184"><a href="book-Z-H-28.html#heading_id_12">Conditionals and sequences</a></li>
<li id="navPoint-185"><a href="book-Z-H-28.html#heading_id_13">Definitions and assignments</a></li>
<li id="navPoint-186"><a href="book-Z-H-28.html#heading_id_14">Procedure applications</a></li>
<li id="navPoint-187"><a href="book-Z-H-28.html#heading_id_15">Evaluating amb expressions</a></li>
<li id="navPoint-188"><a href="book-Z-H-28.html#heading_id_16">Driver loop</a></li></ol></li></ol></li>
<li id="navPoint-189"><a href="book-Z-H-29.html">4.4 Logic Programming</a><ol>
<li id="navPoint-190"><a href="book-Z-H-29.html#heading_id_3">4.4.1 Deductive Information Retrieval</a><ol>
<li id="navPoint-191"><a href="book-Z-H-29.html#heading_id_4">A sample data base</a></li>
<li id="navPoint-192"><a href="book-Z-H-29.html#heading_id_5">Simple queries</a></li>
<li id="navPoint-193"><a href="book-Z-H-29.html#heading_id_6">Compound queries</a></li>
<li id="navPoint-194"><a href="book-Z-H-29.html#heading_id_7">Rules</a></li>
<li id="navPoint-195"><a href="book-Z-H-29.html#heading_id_8">Logic as programs</a></li></ol></li>
<li id="navPoint-196"><a href="book-Z-H-29.html#heading_id_9">4.4.2 How the Query System Works</a><ol>
<li id="navPoint-197"><a href="book-Z-H-29.html#heading_id_10">Pattern matching</a></li>
<li id="navPoint-198"><a href="book-Z-H-29.html#heading_id_11">Streams of frames</a></li>
<li id="navPoint-199"><a href="book-Z-H-29.html#heading_id_12">Compound queries</a></li>
<li id="navPoint-200"><a href="book-Z-H-29.html#heading_id_13">Unification</a></li>
<li id="navPoint-201"><a href="book-Z-H-29.html#heading_id_14">Applying rules</a></li>
<li id="navPoint-202"><a href="book-Z-H-29.html#heading_id_15">Simple queries</a></li>
<li id="navPoint-203"><a href="book-Z-H-29.html#heading_id_16">The query evaluator and the driver loop</a></li></ol></li>
<li id="navPoint-204"><a href="book-Z-H-29.html#heading_id_17">4.4.3 Is Logic Programming Mathematical Logic?</a><ol>
<li id="navPoint-205"><a href="book-Z-H-29.html#heading_id_18">Infinite loops</a></li>
<li id="navPoint-206"><a href="book-Z-H-29.html#heading_id_19">Problems with not</a></li></ol></li>
<li id="navPoint-207"><a href="book-Z-H-29.html#heading_id_20">4.4.4 Implementing the Query System</a><ol>
<li id="navPoint-208"><a href="book-Z-H-29.html#heading_id_21">4.4.4.1 The Driver Loop and Instantiation</a></li>
<li id="navPoint-209"><a href="book-Z-H-29.html#heading_id_22">4.4.4.2 The Evaluator</a></li>
<li id="navPoint-210"><a href="book-Z-H-29.html#heading_id_23">Simple queries</a></li>
<li id="navPoint-211"><a href="book-Z-H-29.html#heading_id_24">Compound queries</a></li>
<li id="navPoint-212"><a href="book-Z-H-29.html#heading_id_25">Filters</a></li>
<li id="navPoint-213"><a href="book-Z-H-29.html#heading_id_26">4.4.4.3 Finding Assertions by Pattern Matching</a></li>
<li id="navPoint-214"><a href="book-Z-H-29.html#heading_id_27">Patterns with dotted tails</a></li>
<li id="navPoint-215"><a href="book-Z-H-29.html#heading_id_28">4.4.4.4 Rules and Unification</a></li>
<li id="navPoint-216"><a href="book-Z-H-29.html#heading_id_29">4.4.4.5 Maintaining the Data Base</a></li>
<li id="navPoint-217"><a href="book-Z-H-29.html#heading_id_30">4.4.4.6 Stream Operations</a></li>
<li id="navPoint-218"><a href="book-Z-H-29.html#heading_id_31">4.4.4.7 Query Syntax Procedures</a></li>
<li id="navPoint-219"><a href="book-Z-H-29.html#heading_id_32">4.4.4.8 Frames and Bindings</a></li></ol></li></ol></li></ol></li>
<li id="navPoint-220"><a href="book-Z-H-30.html">Chapter 5</a><ol>
<li id="navPoint-221"><a href="book-Z-H-31.html">5.1 Designing Register Machines</a><ol>
<li id="navPoint-222"><a href="book-Z-H-31.html#heading_id_3">5.1.1 A Language for Describing Register Machines</a><ol>
<li id="navPoint-223"><a href="book-Z-H-31.html#heading_id_4">Actions</a></li></ol></li>
<li id="navPoint-224"><a href="book-Z-H-31.html#heading_id_5">5.1.2 Abstraction in Machine Design</a></li>
<li id="navPoint-225"><a href="book-Z-H-31.html#heading_id_6">5.1.3 Subroutines</a></li>
<li id="navPoint-226"><a href="book-Z-H-31.html#heading_id_7">5.1.4 Using a Stack to Implement Recursion</a><ol>
<li id="navPoint-227"><a href="book-Z-H-31.html#heading_id_8">A double recursion</a></li></ol></li>
<li id="navPoint-228"><a href="book-Z-H-31.html#heading_id_9">5.1.5 Instruction Summary</a></li></ol></li>
<li id="navPoint-229"><a href="book-Z-H-32.html">5.2 A Register-Machine Simulator</a><ol>
<li id="navPoint-230"><a href="book-Z-H-32.html#heading_id_3">5.2.1 The Machine Model</a><ol>
<li id="navPoint-231"><a href="book-Z-H-32.html#heading_id_4">Registers</a></li>
<li id="navPoint-232"><a href="book-Z-H-32.html#heading_id_5">The stack</a></li>
<li id="navPoint-233"><a href="book-Z-H-32.html#heading_id_6">The basic machine</a></li></ol></li>
<li id="navPoint-234"><a href="book-Z-H-32.html#heading_id_7">5.2.2 The Assembler</a></li>
<li id="navPoint-235"><a href="book-Z-H-32.html#heading_id_8">5.2.3 Generating Execution Procedures for Instructions</a><ol>
<li id="navPoint-236"><a href="book-Z-H-32.html#heading_id_9">Assign instructions</a></li>
<li id="navPoint-237"><a href="book-Z-H-32.html#heading_id_10">Test, branch, and goto instructions</a></li>
<li id="navPoint-238"><a href="book-Z-H-32.html#heading_id_11">Other instructions</a></li>
<li id="navPoint-239"><a href="book-Z-H-32.html#heading_id_12">Execution procedures for subexpressions</a></li></ol></li>
<li id="navPoint-240"><a href="book-Z-H-32.html#heading_id_13">5.2.4 Monitoring Machine Performance</a></li></ol></li>
<li id="navPoint-241"><a href="book-Z-H-33.html">5.3 Storage Allocation and Garbage Collection</a><ol>
<li id="navPoint-242"><a href="book-Z-H-33.html#heading_id_3">5.3.1 Memory as Vectors</a><ol>
<li id="navPoint-243"><a href="book-Z-H-33.html#heading_id_4">Representing Lisp data</a></li>
<li id="navPoint-244"><a href="book-Z-H-33.html#heading_id_5">Implementing the primitive list operations</a></li>
<li id="navPoint-245"><a href="book-Z-H-33.html#heading_id_6">Implementing stacks</a></li></ol></li>
<li id="navPoint-246"><a href="book-Z-H-33.html#heading_id_7">5.3.2 Maintaining the Illusion of Infinite Memory</a><ol>
<li id="navPoint-247"><a href="book-Z-H-33.html#heading_id_8">Implementation of a stop-and-copy garbage collector</a></li></ol></li></ol></li>
<li id="navPoint-248"><a href="book-Z-H-34.html">5.4 The Explicit-Control Evaluator</a><ol>
<li id="navPoint-249"><a href="book-Z-H-34.html#heading_id_3">Registers and operations</a></li>
<li id="navPoint-250"><a href="book-Z-H-34.html#heading_id_4">5.4.1 The Core of the Explicit-Control Evaluator</a><ol>
<li id="navPoint-251"><a href="book-Z-H-34.html#heading_id_5">Evaluating simple expressions</a></li>
<li id="navPoint-252"><a href="book-Z-H-34.html#heading_id_6">Evaluating procedure applications</a></li>
<li id="navPoint-253"><a href="book-Z-H-34.html#heading_id_7">Procedure application</a></li></ol></li>
<li id="navPoint-254"><a href="book-Z-H-34.html#heading_id_8">5.4.2 Sequence Evaluation and Tail Recursion</a><ol>
<li id="navPoint-255"><a href="book-Z-H-34.html#heading_id_9">Tail recursion</a></li></ol></li>
<li id="navPoint-256"><a href="book-Z-H-34.html#heading_id_10">5.4.3 Conditionals, Assignments, and Definitions</a><ol>
<li id="navPoint-257"><a href="book-Z-H-34.html#heading_id_11">Assignments and definitions</a></li></ol></li>
<li id="navPoint-258"><a href="book-Z-H-34.html#heading_id_12">5.4.4 Running the Evaluator</a><ol>
<li id="navPoint-259"><a href="book-Z-H-34.html#heading_id_13">Monitoring the performance of the evaluator</a></li></ol></li></ol></li>
<li id="navPoint-260"><a href="book-Z-H-35.html">5.5 Compilation</a><ol>
<li id="navPoint-261"><a href="book-Z-H-35.html#heading_id_3">An overview of the compiler</a></li>
<li id="navPoint-262"><a href="book-Z-H-35.html#heading_id_4">5.5.1 Structure of the Compiler</a><ol>
<li id="navPoint-263"><a href="book-Z-H-35.html#heading_id_5">Targets and linkages</a></li>
<li id="navPoint-264"><a href="book-Z-H-35.html#heading_id_6">Instruction sequences and stack usage</a></li></ol></li>
<li id="navPoint-265"><a href="book-Z-H-35.html#heading_id_7">5.5.2 Compiling Expressions</a><ol>
<li id="navPoint-266"><a href="book-Z-H-35.html#heading_id_8">Compiling linkage code</a></li>
<li id="navPoint-267"><a href="book-Z-H-35.html#heading_id_9">Compiling simple expressions</a></li>
<li id="navPoint-268"><a href="book-Z-H-35.html#heading_id_10">Compiling conditional expressions</a></li>
<li id="navPoint-269"><a href="book-Z-H-35.html#heading_id_11">Compiling sequences</a></li>
<li id="navPoint-270"><a href="book-Z-H-35.html#heading_id_12">Compiling lambda expressions</a></li></ol></li>
<li id="navPoint-271"><a href="book-Z-H-35.html#heading_id_13">5.5.3 Compiling Combinations</a><ol>
<li id="navPoint-272"><a href="book-Z-H-35.html#heading_id_14">Applying procedures</a></li>
<li id="navPoint-273"><a href="book-Z-H-35.html#heading_id_15">Applying compiled procedures</a></li></ol></li>
<li id="navPoint-274"><a href="book-Z-H-35.html#heading_id_16">5.5.4 Combining Instruction Sequences</a></li>
<li id="navPoint-275"><a href="book-Z-H-35.html#heading_id_17">5.5.5 An Example of Compiled Code</a></li>
<li id="navPoint-276"><a href="book-Z-H-35.html#heading_id_18">5.5.6 Lexical Addressing</a></li>
<li id="navPoint-277"><a href="book-Z-H-35.html#heading_id_19">5.5.7 Interfacing Compiled Code to the Evaluator</a><ol>
<li id="navPoint-278"><a href="book-Z-H-35.html#heading_id_20">Interpretation and compilation</a></li></ol></li></ol></li></ol></li></ol></nav>
</body></html>
